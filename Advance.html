<head>
	<title>Javascript Code Dump By Vatsal Patel</title>
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body onload="mastermind();">
	<div class="head" id="head">Javascript Code Dump By Vatsal Patel</div><br>
	<br>
	<div id="master"><lable class="Title deleat count" vat-id="1">ID : 1 &amp; Title : null vs Undefined</lable><textarea class="txt deleat" vat-id="1">var name = null; //null
var age; //undefined 

console.log(typeof null); // objec 
console.log(typeof undefined); // undefined 

console.log( null === undefined ); //false
console.log( null == undefined );  //true

//So for if condi. you can use any one,

if(name==null){
	//executed
}
if(name==undefined){
	//executed
}</textarea><lable class="Title deleat count" vat-id="2">ID : 2 &amp; Title : for In vs for of (in for obj &amp; of for array) </lable><textarea class="txt deleat" vat-id="2">var person = {fname:"John", lname:"Doe", age:25}; 
  
  var text = "";
  var x;
  for (x in person) {
    text += person[x] + " ";
  }

  console.log(text)  // John Doe 25

var cars = ['BMW', 'Volvo', 'Mini'];
var x;
  var text = "";
for (x of cars) {
text += x + " ";
}

 console.log(text)  // BMW Volvo Mini</textarea><lable class="Title deleat count" vat-id="3">ID : 3 &amp; Title : IIFE</lable><textarea class="txt deleat" vat-id="3">An IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined.
(function () {
    statements
})();

It is a design pattern which is also known as a Self-Executing Anonymous Function and contains two major parts:
The variable within the expression can not be accessed from outside it.
(function () {
    var aName = "Barry";
})();
// Variable aName is not accessible from the outside scope


Assigning the IIFE to a variable stores the function's return value, not the function definition itself.


var result = (function () {
    var name = "Barry";
    return name;
})();
// Immediately creates the output:
result; // "Barry"</textarea><lable class="Title deleat count" vat-id="4">ID : 4 &amp; Title : The conditional (ternary) operator(?)</lable><textarea class="txt deleat" vat-id="4">The conditional (ternary) operator(?), is used as a shortcut for the if statement.

function getFee(isMember) {
  return (isMember ? '$2.00' : '$10.00');
}

console.log(getFee(true));
// expected output: "$2.00"

console.log(getFee(false));
// expected output: "$10.00"

console.log(getFee(null));
// expected output: "$10.00"</textarea><lable class="Title deleat count" vat-id="5">ID : 5 &amp; Title : parameters vs arguments</lable><textarea class="txt deleat" vat-id="5">Function parameters are the names listed in the function's definition. Function arguments are the real values passed to the function.</textarea><lable class="Title deleat count" vat-id="6">ID : 6 &amp; Title : Function Expressions</lable><textarea class="txt deleat" vat-id="6">A JavaScript function can also be defined using an expression.

A function expression can be stored in a variable:

var x = function (a, b) {return a * b};
var z = x(4, 3);

After a function expression has been stored in a variable, the variable can be used as a function:</textarea><lable class="Title deleat count" vat-id="7">ID : 7 &amp; Title : hoisting </lable><textarea class="txt deleat" vat-id="7">definition of hoisting suggests that variable and function declarations are physically moved to the top of your code, but this is not in fact what happens. Instead, the variable and function declarations are put into memory during the compile phase, but stay exactly where you typed them in your code.

it allows you to use a function before you declare it in your code.

The variables can be initialized and used before they are declared.


JavaScript only hoists declarations, not initializations. If a variable is declared and initialized after using it, the value will be undefined.


console.log(num); // Returns undefined, as only declaration was hoisted, no initialization has happened at this stage
var num; // Declaration
num = 6; // Initialization

Initializations using let and const are also not hoisted. 


// Example with let:
a = 1; // initialization.
let a; // Throws ReferenceError: Cannot access 'a' before initialization

// Example with const:
a = 1; // initialization.
const a; // Throws SyntaxError: Missing initializer in const declaration


JavaScript in strict mode does not allow variables to be used if they are not declared.



</textarea><lable class="Title deleat count" vat-id="8">ID : 8 &amp; Title : Template literal   backtick (`)</lable><textarea class="txt deleat" vat-id="8">syntx
var s=`some string`;

\n not required,..

// Without template literal 
console.log('Some text that I want \non two lines!'); 
  
// With template literal 
console.log(`Some text that I want 
on two lines!`); 






</textarea><lable class="Title deleat count" vat-id="9">ID : 9 &amp; Title : Expressions ${} syntax</lable><textarea class="txt deleat" vat-id="9">let principal = 1000; 
let noofyears = 1; 
let rateofinterest = 7; 
  
let SI = `Simple Interest is ${(principal * 
            noofyears * rateofinterest)/100}`; </textarea><lable class="Title deleat count" vat-id="10">ID : 10 &amp; Title : Tagged Templates</lable><textarea class="txt deleat" vat-id="10">Tagged Literal is written like a function definition,

 but the difference is when this literal is called.

 There is no parenthesis() to a literal call.

 An array of Strings are passed as a parameter to a literal.


function TaggedLiteralEg(strings) { 
    document.write(strings); 
} 
  
TaggedLiteralEg `Vatsal`; 


</textarea><lable class="Title deleat count" vat-id="11">ID : 11 &amp; Title : Rest parameter ... (must be last parameter )</lable><textarea class="txt deleat" vat-id="11">// rest with function and other arguments 
function fun(a,b,...c){ 
	console.log(`${a} ${b}`); //Mukul Latiyan 
	console.log(c); //[ 'Lionel', 'Messi', 'Barcelona' ] 
	console.log(c[0]); //Lionel 
	console.log(c.length); //3 
	console.log(c.indexOf('Lionel')); //0 
} 
fun('Mukul','Latiyan','Lionel','Messi','Barcelona'); 
</textarea><lable class="Title deleat count" vat-id="12">ID : 12 &amp; Title : Avoid Wrong Array copy method</lable><textarea class="txt deleat" vat-id="12">// changed the original array 
let arr = ['a','b','c']; 
let arr2 = arr; 

arr2.push('d'); 

console.log(arr2); 
console.log(arr); // even affected the original array(arr) 
</textarea><lable class="Title deleat count" vat-id="13">ID : 13 &amp; Title : spread operator for copying array</lable><textarea class="txt deleat" vat-id="13">let arr = ['a','b','c']; 
let arr2 = [...arr]; 

console.log(arr); // [ 'a', 'b', 'c' ] 

arr2.push('d'); //inserting an element at the end of arr2 

console.log(arr2); // [ 'a', 'b', 'c', 'd' ] 
console.log(arr); // [ 'a', 'b', 'c' ] 
</textarea><lable class="Title deleat count" vat-id="14 ">ID : 14  &amp; Title : Array Expand concatenate using spread operator</lable><textarea class="txt deleat" vat-id="14 ">// normally used expand method 
let arr = ['a','b']; 
let arr2 = [arr,'c','d'];
let arr3 = [...arr,'c','d'];  

console.log(arr2); // [ [ 'a', 'b' ], 'c', 'd' ] 
console.log(arr3); // [ 'a', 'b', 'c', 'd' ] </textarea><lable class="Title deleat count" vat-id="15">ID : 15 &amp; Title : Math operation on array</lable><textarea class="txt deleat" vat-id="15">// min in an array using Math.min() 
let arr = [1,2,3,-1]; 
console.log(Math.min(arr)); //NaN 
console.log(Math.min(...arr)); //-1 </textarea><lable class="Title deleat count" vat-id="16">ID : 16 &amp; Title : spread operator VS a rest parameter</lable><textarea class="txt deleat" vat-id="16">How do we tell the difference? Well it entirely depends on how we use it. 


The spread operator allows us to expand elements. 

With rest parameters we were able to get a list of arguments into an array. 

spread operators however, let us unpack elements in an array to single/individual arguments.</textarea><lable class="Title deleat count" vat-id="17">ID : 17 &amp; Title : destructuring-assignment,destructuring-assignment,Array to variable</lable><textarea class="txt deleat" vat-id="17">var names = ["alpha", "beta", "gamma", "delta"]; 
var [firstName, secondName] = names; 
      
console.log(firstName);//"alpha" 
console.log(secondName);//"beta" </textarea><lable class="Title deleat count" vat-id="18">ID : 18 &amp; Title : swap-the-values-of-two-variables-in-javascript</lable><textarea class="txt deleat" vat-id="18">a=5;
b="hi"
b = [a, a = b][0];

console.log(a);//hi
console.log(b);//5

//If you are using ES6+ try this:

[a, b] = [b, a];</textarea><lable class="Title deleat count" vat-id="19">ID : 19 &amp; Title : exponentiation-operator</lable><textarea class="txt deleat" vat-id="19">Math.pow(99,99); // 3.697296376497263e+197
99 ** 99; // 3.697296376497268e+197

Math.pow(2,2) === 2**2; // FALSE


** not supported in IE,.</textarea><lable class="Title deleat count" vat-id="20">ID : 20 &amp; Title : trunc vs floor vs ceil vs round</lable><textarea class="txt deleat" vat-id="20">var v;
[Math.trunc(v), Math.floor(v), Math.ceil(v), Math.round(v)]

 3.87 : [ 3,  3,  4,  4]
 3.14 : [ 3,  3,  4,  3]
-3.14 : [-3, -4, -3, -3]
-3.87 : [-3, -4, -3, -4]

// trunc only remove dot and digit after dot
// floor always return lower value
// ceil always return Higher value
// round works according to situation
</textarea><lable class="Title deleat count" vat-id="21">ID : 21 &amp; Title : Live and static DOM elements</lable><textarea class="txt deleat" vat-id="21">const coll = document.getElementsByTagName("span");
const list = document.querySelectorAll("span");
console.log("(before) coll.length = " + coll.length);//1
console.log("(before) list.length = " + list.length);//1

console.log("Adding another span");
document.body.appendChild(
  document.createElement("span")
);
console.log("(after)  coll.length = " + coll.length);//2
console.log("(after)  list.length = " + list.length);//1</textarea><lable class="Title deleat count" vat-id="22">ID : 22 &amp; Title : parseInt second parameter,..... </lable><textarea class="txt deleat" vat-id="22">console.log(parseInt("He was 40"));//NaN
console.log(parseInt("He was 40",10));//NaN
console.log(parseInt("40 He was",10));//40
console.log(parseInt("10", 8));//8
console.log(parseInt("0x10"));//16
console.log(parseInt("34 45 66"));//34
console.log(parseInt("35.55"));//35</textarea><lable class="Title deleat count" vat-id="23">ID : 23 &amp; Title : JavaScript closure</lable><textarea class="txt deleat" vat-id="23">A closure refers to a function that has access to variables from its outer scope. When a function meets this criterion, it is considered a closure. The term "closure" is used to describe this specific behavior in JavaScript.


function outerFunction() {
  var outerVariable = 'I am outside!';

  function innerFunction() {
    console.log(outerVariable);
  }

  return innerFunction;
}

var closureExample = outerFunction();
closureExample(); // Output: "I am outside!"


accessing global or window variables does not necessarily make a function a closure. Closures specifically refer to functions that have access to variables from their outer scope, which is not limited to global or window variables.</textarea><lable class="Title deleat count" vat-id="24">ID : 24 &amp; Title : async and defer</lable><textarea class="txt deleat" vat-id="24">The async and defer attributes are used when including external JavaScript files in HTML.

If neither attribute is specified, the script is loaded synchronously and blocks HTML parsing.

Synchronous load blocks HTML parsing and executes scripts immediately.
Asynchronous load (async) allows scripts to be downloaded and executed independently while HTML parsing continues.
Deferred load (defer) ensures scripts are executed after the entire HTML document has been parsed, in the order they appear.</textarea><lable class="Title deleat count" vat-id="25">ID : 25 &amp; Title : this keyword</lable><textarea class="txt deleat" vat-id="25"> this is a special keyword that refers to the object that is currently executing the code. 

Global scope: In the global scope (outside of any function), this refers to the global object, which is typically window in a web browser environment 

Event handlers: When a function is used as an event handler, this refers to the DOM element that triggered the event.</textarea><lable class="Title deleat count" vat-id="26">ID : 26 &amp; Title : JavaScript single-threaded and has a synchronous execution model</lable><textarea class="txt deleat" vat-id="26">JavaScript is inherently single-threaded and has a synchronous execution model, which means that code is executed in a sequential and blocking manner by default. Each line of code is executed one after the other, and the program waits for each operation to complete before moving on to the next.

However, JavaScript also has mechanisms to handle asynchronous operations, allowing non-blocking execution. Asynchronous operations, such as fetching data from a server or reading files, do not halt the program's execution while waiting for a response. Instead, they are initiated, and the program continues to execute other tasks without waiting for the asynchronous operation to complete.

The main difference between synchronous and asynchronous code execution is how they handle waiting for operations to finish:

Synchronous Execution:

Code is executed in a sequential and blocking manner.
Each operation must complete before the program moves to the next one.
The program waits for I/O operations or time-consuming tasks to finish, blocking further execution.
Asynchronous Execution:

Code is executed non-sequentially, allowing other operations to proceed while waiting for a particular operation to complete.
Asynchronous operations are initiated, and the program continues executing without waiting for them to finish.
A callback function or promises are typically used to handle the completion of asynchronous operations and perform further actions.
Asynchronous execution is crucial for handling time-consuming tasks without blocking the main thread, which would result in unresponsive user interfaces or slow performance. JavaScript provides mechanisms like callbacks, promises, and async/await to handle asynchronous code in a more organized and readable way.

By using asynchronous techniques, JavaScript can efficiently handle I/O operations, network requests, and other time-consuming tasks, providing a more responsive and performant user experience.</textarea><lable class="Title deleat count" vat-id="27">ID : 27 &amp; Title : polyfill</lable><textarea class="txt deleat" vat-id="27">A polyfill, in the context of web development, is a piece of code or a script that provides modern functionality on older browsers or environments that do not natively support that functionality. It "fills in" the gaps or missing features to ensure consistent behavior across different platforms.</textarea></div><br>
	<br>
	<textarea class="sub subover" id="code0" placeholder="ID"></textarea> 
	<textarea class="sub subover" id="code1" placeholder="Title"></textarea> <br>
	<textarea class="sub subover" id="code2" placeholder="code"></textarea><br>
	<a href="javascript:runner()" id="btn">Submit</a> <a href="javascript:deleat()" id="btn">Delete</a> <a href="javascript:down()" id="btn">Download</a> 
	<textarea class="sub subover subover1" id="code3">Number of ID : 27</textarea> 
	<br>
	<script type="text/javascript" src="main.js"></script></body>